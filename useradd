#!/usr/bin/ruby
# -*- coding: utf-8 -*-

require 'active_ldap'
require 'optparse'
require 'ostruct'

require 'config/user'
require 'config/group'
require 'config/connect'

##
# Options

options = OpenStruct.new
options.name = false
options.gid = false # -g, --gid
options.uid = false # -u, --uid
options.groups = false # -G, --groups
options.home = false # -d, --home
options.shell = false # -s, --shell
options.first = false # -f, --first
options.last = false # -l, --last
options.cn = false # automatically created
options.mod = false # -m, --modify

##
# OptionParser Object

opts = OptionParser.new do |opts|
  opts.banner = "Usage: useradd.rb [options] username"

  opts.separator ""
  opts.separator "Specific options:"

  opts.on("-g", "--gid GID",
          "GID Number, defaults to 100") do |gid|
    options.gid = gid
  end

  opts.on("-u", "--uid UID",
          "UID Number, defaults to highest existing uid+1") do |uid|
    options.uid = uid
  end

  opts.on("-G", "--groups GROUP1,GROUP2,...",
          "Add user to GROUP1, GROUP2, ...") do |groups|
    options.groups = groups.split(',')
  end

  opts.on("-d", "--home HOME",
          "Set home folder, defaults to /home/NAME") do |home|
    options.home = home
  end

  opts.on("-s", "--shell SHELL",
          "Set shell of user, defaults to /bin/bash") do |shell|
    options.shell = shell
  end

  opts.on("-f", "--first FIRST",
          "Set first name") do |first|
    options.first = first
  end

  opts.on("-l", "--last SURNAME",
          "Set surname") do |last|
    options.last = last
  end

  opts.on("-m", "--modify",
          "Modify existing user") do |mod|
    options.mod = true
  end

  opts.separator ""
  opts.separator "Common options:"

  opts.on_tail("-h", "--help", "Show this message") do
    puts opts
    exit
  end

end

opts.parse!(ARGV)
   
options.name = ARGV[0] || raise( "Username missing." )

##
# Checks for name and uid
# create default home if not given

if options.mod

  if !User.exists?(options.name)
    $stderr.puts("User #{options.name} does not exist.")
    exit 1
  end
  
  user = User.find(options.name)

else
  
  if User.exists?(options.name)
    $stderr.puts("User #{options.name} already exists.")
    exit 1
  end

  options.gid = 100 unless options.gid
  
  if !options.uid
    options.uid = 999
    User.find(:all, :attribute => 'uidNumber').collect { |user| user.uidNumber>options.uid ? options.uid=user.uidNumber : false }
    options.uid+=1
  end

  options.home = "/home/#{options.name}" unless options.home
  options.shell = "/bin/bash" unless options.shell
  
  if options.first && options.last
    options.cn = options.first + " " + options.last
  elsif options.first && !options.last
    options.cn = options.first
  elsif !options.first && options.last
    options.cn = options.last
  else
    options.cn = false
  end

  user = User.new(options.name)

end

##
# Create user

def mod_user(user, attributes)
# user hash or something instead of ostruct to support each here.
#  attributes.each {|key, val| puts "test" }
  user.cn = attributes.cn
  user.login_shell = attributes.shell
  user.uid_number = attributes.uid
  user.gid_number = attributes.gid
  user.home_directory = attributes.home
  user.sn = attributes.last
  user.given_name = attributes.first

  return user

end

mod_user(user,options)

puts user.to_ldif

#unless user.save
#  puts "User creation failed"
#  puts user.errors.full_messages
#  exit 1
#end
